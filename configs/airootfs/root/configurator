#!/bin/bash

# Rely on Omarchy for styling and error handling
source "$OMARCHY_INSTALL/helpers/all.sh"

# Ensure tzupdate is available for guessing timezone
command -v tzupdate >/dev/null || sudo pacman -Sy --noconfirm tzupdate

abort() {
  gum style "${1:-Aborted installation}"
  echo
  gum style "You can retry later by running: ./.automated_script.sh"
  exit 1
}

step() {
  clear_logo
  echo
  gum style "$1"
  echo
}

notice() {
  clear_logo
  echo
  gum spin --spinner "pulse" --title "$1" -- sleep "${2:-2}"
  echo
}

# STEP 1: KEYBOARD LAYOUT

keyboard_form() {
  step "Let's setup your machine..."
  keyboards=$'Azerbaijani|azerty
Belarusian|by
Belgian|be-latin1
Bosnian|ba
Bulgarian|bg-cp1251
Croatian|croat
Czech|cz
Danish|dk-latin1
Dutch|nl
English (UK)|uk
English (US)|us
English (US, Dvorak)|dvorak
Estonian|et
Finnish|fi
French|fr
French (Canada)|cf
French (Switzerland)|fr_CH
Georgian|ge
German|de
German (Switzerland)|de_CH-latin1
Greek|gr
Hebrew|il
Hungarian|hu
Icelandic|is-latin1
Irish|ie
Italian|it
Japanese|jp106
Kazakh|kazakh
Khmer (Cambodia)|khmer
Kyrgyz|kyrgyz
Lao|la-latin1
Latvian|lv
Lithuanian|lt
Macedonian|mk-utf
Norwegian|no-latin1
Polish|pl
Portuguese|pt-latin1
Portuguese (Brazil)|br-abnt2
Romanian|ro
Russian|ru
Serbian|sr-latin
Slovak|sk-qwertz
Slovenian|slovene
Spanish|es
Spanish (Latin American)|la-latin1
Swedish|sv-latin1
Tajik|tj_alt-UTF8
Turkish|trq
Ukrainian|ua'
  choice=$(printf '%s\n' "$keyboards" | cut -d'|' -f1 | gum choose --height 10 --selected "English (US)" --header "Select keyboard layout") || abort
  keyboard=$(printf '%s\n' "$keyboards" | awk -F'|' -v c="$choice" '$1==c{print $2; exit}')

  if [[ $(tty 2>/dev/null) == "/dev/tty"* ]]; then
    loadkeys "$keyboard" 2>/dev/null
  fi
}

keyboard_form

# STEP 2: USER

user_form() {
  step "Let's setup your user account..."

  while true; do
    username=$(gum input --placeholder "Alphanumeric without spaces (like dhh)" --prompt.foreground="#845DF9" --prompt "Username> ") || abort

    if [[ "$username" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]]; then
      break
    else
      notice "Username must be alphanumeric with no spaces" 1
    fi
  done

  while true; do
    password=$(gum input --placeholder "Used for user + root + encryption" --prompt.foreground="#845DF9" --password --prompt "Password> ") || abort
    password_confirmation=$(gum input --placeholder "Must match the password you just typed" --prompt.foreground="#845DF9" --password --prompt "Confirm> ") || abort

    if [[ -n "$password" && "$password" == "$password_confirmation" ]]; then
      break
    elif [[ -z "$password" ]]; then
      notice "Your password can't be blank!" 1
    else
      notice "Passwords didn't match!" 1
    fi
  done

  password_hash=$(printf '%s' "$password" | openssl passwd -6 -stdin)

  full_name=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Full name> ")
  email_address=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Email address> ")

  while true; do
    hostname=$(gum input --placeholder "Alphanumeric without spaces (or return for 'omarchy')" --prompt.foreground="#845DF9" --prompt "Hostname> ")

    if [[ "$hostname" =~ ^[A-Za-z_][A-Za-z0-9_-]*\$?$ ]]; then
      break
    elif [[ -z $hostname ]]; then
      hostname="omarchy"
      break
    else
      notice "Hostname must be alphanumeric using dashes or underscores but no spaces" 1
    fi
  done

  geo_guessed_timezone=$(tzupdate -p 2>/dev/null)

  if [[ -n $geo_guessed_timezone ]]; then
    timezone=$(timedatectl list-timezones | gum choose --height 10 --selected "$geo_guessed_timezone" --header "Timezone") || abort
  else
    timezone=$(timedatectl list-timezones | gum filter --height 10 --header "Timezone") || abort
  fi
}

user_form

while true; do
  echo -e "Field,Value
Username,$username
Password,$(printf "%${#password}s" | tr ' ' '*')
Full name,${full_name:-[Skipped]}
Email address,${email_address:-[Skipped]}
Hostname,$hostname
Timezone,$timezone
Keyboard,$keyboard" |
    gum table -s "," -p | sed "s/^/${PADDING_LEFT_SPACES}/"

  echo
  if gum confirm --negative "No, change it" "Does this look right?"; then
    break
  else
    keyboard_form
    user_form
  fi
done

# STEP 3: PARTITIONS

get_partition_info() {
  local partition="$1"
  local size fstype

  size=$(lsblk -dno SIZE "$partition" 2>/dev/null)
  fstype=$(lsblk -dno FSTYPE "$partition" 2>/dev/null)

  local display="$partition"
  [[ -n "$size" ]] && display="$display ($size)"
  [[ -n "$fstype" ]] && display="$display [$fstype]"

  echo "$display"
}

partition_form() {
  step "Let's select your partitions..."

  local boot_source
  boot_source=$(findmnt -no SOURCE /run/archiso/bootmnt 2>/dev/null || true)

  local available_partitions
  available_partitions=$(
    lsblk -pno NAME,TYPE |
      awk '$2=="part"{print $1}' |
      grep -E '/dev/(sd|hd|vd|nvme|mmcblk|xv)' |
      { if [[ -n "$boot_source" ]]; then grep -Fvx "$boot_source"; else cat; fi; }
  )

  if [[ -z "$available_partitions" ]]; then
    abort "No available partitions found!"
  fi

  # EFI/Boot partition
  step "Select EFI/Boot partition..."
  local efi_options=""
  while IFS= read -r partition; do
    if [[ -n "$partition" ]]; then
      partition_info=$(get_partition_info "$partition")
      efi_options="$efi_options$partition_info"$'\n'
    fi
  done <<<"$available_partitions"

  efi_display=$(echo "$efi_options" | gum choose --header "Select EFI/Boot partition (e.g., /dev/sda1)") || abort
  efi_device=$(echo "$efi_display" | awk '{print $1}')

  # Main root partition
  step "Select main partition for / (root)..."
  main_display=$(echo "$efi_options" | gum choose --header "Select main partition for / (e.g., /dev/sda2)") || abort
  main_device=$(echo "$main_display" | awk '{print $1}')

  # Swap partition (optional)
  step "Select swap partition (optional)..."
  swap_display=$(echo "$efi_options" | gum choose --header "Select swap partition (or press Escape to skip)") || swap_display=""
  swap_device=$(echo "$swap_display" | awk '{print $1}')
}

partition_form

while true; do
  echo
  gum style "Partition Selection:"
  echo "EFI/Boot: $efi_device"
  echo "Root (/): $main_device"
  echo "Swap: ${swap_device:-[None]}"
  echo

  gum style "WARNING: Selected partitions will be formatted!"
  echo

  if gum confirm --negative "No, change it" "Does this look right?"; then
    break
  else
    partition_form
  fi
done

clear

# Save metadata
echo "$full_name" >user_full_name.txt
echo "$email_address" >user_email_address.txt

password_escaped=$(echo -n "$password" | jq -Rsa)
password_hash_escaped=$(echo -n "$password_hash" | jq -Rsa)
username_escaped=$(echo -n "$username" | jq -Rsa)

cat <<-_EOF_ >user_credentials.json
{
    "encryption_password": $password_escaped,
    "root_enc_password": $password_hash_escaped,
    "users": [
        {
            "enc_password": $password_hash_escaped,
            "groups": [],
            "sudo": true,
            "username": $username_escaped
        }
    ]
}
_EOF_

# Detect T2 Mac
if lspci -nn 2>/dev/null | grep -q "106b:180[12]"; then
  kernel_choice="linux-t2"
else
  kernel_choice="linux"
fi

# Build partition config
declare -a partitions_to_config
partitions_to_config+=("$efi_device")
partitions_to_config+=("$main_device")
[[ -n "$swap_device" ]] && partitions_to_config+=("$swap_device")

# Build device modifications
device_mods='[]'
efi_device_config=$(
  cat <<-'EOF'
{
    "device": "EFI_DEVICE_PLACEHOLDER",
    "partitions": [
        {
            "btrfs": [],
            "flags": [ "boot", "esp" ],
            "fs_type": "fat32",
            "mount_options": [],
            "mountpoint": "/boot",
            "status": "format",
            "type": "primary"
        }
    ],
    "wipe": false
}
EOF
)
efi_device_config="${efi_device_config//EFI_DEVICE_PLACEHOLDER/$efi_device}"

root_device_config=$(
  cat <<-'EOF'
{
    "device": "ROOT_DEVICE_PLACEHOLDER",
    "partitions": [
        {
            "fs_type": "ext4",
            "mountpoint": "/",
            "status": "format",
            "type": "primary"
        }
    ],
    "wipe": false
}
EOF
)
root_device_config="${root_device_config//ROOT_DEVICE_PLACEHOLDER/$main_device}"

# Build disk encryption config
if [[ -n "$swap_device" ]]; then
  swap_config=$(
    cat <<-'EOF'
{
    "device": "SWAP_DEVICE_PLACEHOLDER",
    "partitions": [
        {
            "fs_type": "swap",
            "mountpoint": "swap",
            "status": "format",
            "type": "primary"
        }
    ],
    "wipe": false
}
EOF
  )
  swap_config="${swap_config//SWAP_DEVICE_PLACEHOLDER/$swap_device}"
  device_mods=$(jq -n --argjson efi "$efi_device_config" --argjson root "$root_device_config" --argjson swap "$swap_config" '[$efi, $root, $swap]')
else
  device_mods=$(jq -n --argjson efi "$efi_device_config" --argjson root "$root_device_config" '[$efi, $root]')
fi

cat <<-_EOF_ >user_configuration.json
{
    "app_config": null,
    "archinstall-language": "English",
    "auth_config": {},
    "audio_config": { "audio": "pipewire" },
    "bootloader": "Grub",
    "custom_commands": [],
    "disk_config": {
        "config_type": "custom_layout",
        "device_modifications": $(echo "$device_mods" | jq -c .),
        "disk_encryption": {
            "encryption_type": "luks",
            "partitions": [ "$main_device" ],
            "encryption_password": $password_escaped
        }
    },
    "hostname": "$hostname",
    "kernels": [ "$kernel_choice" ],
    "network_config": { "type": "iso" },
    "ntp": true,
    "parallel_downloads": 8,
    "script": null,
    "services": [],
    "timezone": "$timezone",
    "locale_config": {
        "kb_layout": "$keyboard",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US.UTF-8"
    },
    "mirror_config": {
        "custom_repositories": [],
        "custom_servers": [
            {"url": "https://mirror.omarchy.org/\$repo/os/\$arch"},
            {"url": "https://mirror.rackspace.com/archlinux/\$repo/os/\$arch"},
            {"url": "https://geo.mirror.pkgbuild.com/\$repo/os/\$arch"}
        ],
        "mirror_regions": {},
        "optional_repositories": []
    },
    "packages": [
        "base-devel",
        "git",
        "omarchy-keyring"
    ],
    "profile_config": {
        "gfx_driver": null,
        "greeter": null,
        "profile": {}
    },
    "version": "3.0.9"
}
_EOF_

if [[ $1 == "dry" ]]; then
  echo -e "User Configuration:"
  cat user_configuration.json

  echo -e "\n\nUser Credentials:"
  cat user_credentials.json

  echo -e "\n\nUser Full Name:"
  cat user_full_name.txt

  echo -e "\nUser Email Address:"
  cat user_email_address.txt

  rm user_configuration.json user_credentials.json user_full_name.txt user_email_address.txt
fi